<!--
`cbn-select` is a highly-customizable input with selectable dropdown values.

Features:
- options can be specified using the "options" attribute (as a JSON array) or by using the `cbn-data-source` element;
- supports single/multiple values to be selected;
- dropdown is filterable;
- options are editable (optional, when "freeText" is enabled);
- you can use it to select from any JSON objects list; you can override the value, label and filter properties.

Example:
```
    <cbn-select name="numbers" multiple freeText
                options="[ "One", "Two", "Three" ]">
    </cbn-select>
```

<br />
### Styling

The stock `cbn-select` has paper-like look. 
You can customize it using the following CSS mixins: 

Custom property                | Description                       | Default
-------------------------------|-----------------------------------|--------------------
`--cbn-select-container`       | Overrides for the main container  | `{ }`


   TODO: implement customizable styles


@group CBN Elements
@element cbn-form
@demo demo/index.html
-->

<link rel="import" href="lib/include.html" />

<link rel="import" href="../iron-icon/iron-icon.html" />
<link rel="import" href="../iron-icons/iron-icons.html" />
<link rel="import" href="../cbn-data-source/cbn-data-source.html" />
<link rel="import" href="../cbn-data-source/consumer-behavior.html" />

<link rel="import" href="styles.html" />

<dom-module id="cbn-select">
	<template>
		<style>
			:host {
				outline: none;
			}
		</style>
		<style include="cbn-select-styles"></style>
		
		<cbn-data-filter id="filter" auto="false"
				filter-property="[[filterProperty]]" filter-mode="[[filterMode]]"></cbn-data-filter>
		
		<div id="container" tabindex="-1" class$="[[_computeContainerClass(_status.open)]]">
			
			<template is="dom-if" if="[[_computeShowChips(multiple,alwaysShowChips)]]">
				<template is="dom-repeat" items="[[_selectedOptions]]" as="item">
					<div class$="[[_computeSelectedItemClass(item.highlighted,item.editing)]]"
							on-tap="_selectedOptionTap" on-dblclick="_selectedOptionDblClick">
						
						<template is="dom-if" if="[[item.editing]]">
							<input class="option-editor" type="text" title="Edit value" value="{{_editQuery::input}}"
								   size$="[[_computeEditInputSize(_editQuery)]]">
						</template>
						<template is="dom-if" if="[[!item.editing]]">[[item.label]]</template>
						
						<a class="removeBtn" on-tap="_removeBtnTap">
							<iron-icon icon="icons:backspace"></iron-icon>
						</a>
					</div>
				</template>
			</template>
			
			<input id="input" type="text" value="{{_inputValue}}" class="text-input"
					title="[[placeholder]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]"
					on-tap="_dropDownButtonTap" on-input="_queryInputHandler">
			
			<div id="options-wrapper">
				<div id="options">
					<template is="dom-repeat" items="[[_filteredOptions]]" as="item">
						<div class$="[[_computeDropdownItemClass(item.highlighted)]]"
							 on-tap="_dropdownOptionTap">[[item.label]]</div>
					</template>
					<template is="dom-if" if="[[_status.optionsLoading]]">
						<div class="loading">Loading options ...</div>
					</template>
					<template is="dom-if" if="[[_computeEmptyOptionsList(_status.optionsLoading, _filteredOptions)]]">
						<div class="empty">No available options.</div>
					</template>
				</div>
			</div>
			<div id="dropdownBtn" on-tap="_dropDownButtonTap">
				<iron-icon icon="icons:arrow-drop-down"></iron-icon>
			</div>
		</div>
		
	</template>
</dom-module>

<script>
	(function (scope) {
		
		//noinspection JSUnusedGlobalSymbols
		scope.CbnSelectPrototype = {
			is: 'cbn-select',
			
			properties: {
				
				/**
				 * Whether multiple selected values are allowed.
				 * If true, `value` will be an Array.
				 */
				multiple: {
					type: Boolean,
					value: false,
					reflectToAttribute: true
				},
				
				/**
				 * Whether the entered value needs to be strictly found inside the options array (false) or any 
				 * text can be freely entered by the user (true).
				 * Should only be used if the option items are String (and *not* Object).
				 */
				freeText: {
					type: Boolean,
					value: false
				},
				
				/**
				 * Whether duplicate options are allowed to be selected. Only used if the `multiple` attribute is true.
				 * If this is false (default), the selected options are removed from the dropdown list and inserting duplicate value is a no-op.
				 */
				allowDuplicates: {
					type: Boolean,
					value: false
				},
				
				/**
				 * An array with the select options.
				 * Also accepts a callback function (as property).
				 * 
				 * Cannot be used together with {@link #dataSource}.
				 */
				options: {
					type: Array,
					value: function() { return []; }
				},
				
				/**
				 * The selector or reference to a `cbn-data-source` element that supplies the available options.
				 * Exclusive with {@link #options}.
				 * 
				 * The element is searched for inside the parent form.
				 */
				dataSource: {
					type: String
				},
				
				/**
				 * Specifies the path to an option item to get the item label text from.
				 * Only used if the option is an Object (if String, then its value will be used as both label and 
				 * output value).
				 */
				itemLabelProperty: {
					type: String,
					value: 'label'
				},
				
				/**
				 * Specifies what property of the option object to set as model value.
				 * 
				 * Use empty/false if you want the entire object to be used.
				 */
				itemValueProperty: {
					type: String,
					value: ''
				},
				
				/**
				 * Specify the option item property to use to filter the options list.
				 * Specify empty value if your data is a String list and you want to compare the items directly.
				 */
				filterProperty: {
					type: String,
					value: 'label'
				},
				
				/**
				 * The mode to use for filtering the displayed options. 
				 * 
				 * Check cbn-data-filter's `filterMode` for all available modes.
				 */
				filterMode: {
					type: String,
					value: 'begins-ci'
				},
				
				/**
				 * The placeholder to show when there is no value entered.
				 */
				placeholder: {
					type: String,
					value: ''
				},
				
				/**
				 * Set this to true to always show the selection chips.
				 * Automatically set to true when multiple selection is enabled.
				 */
				alwaysShowChips: {
					type: Boolean,
					value: false
				},
				
				/**
				 * Stores the main input's current value (used for add / query / showing the selected value in single mode).
				 */
				_inputValue: {
					type: String,
					notify: true,
					value: ''
				},
				
				/**
				 * Stores the edit option input's current value.
				 */
				_editQuery: {
					type: String,
					value: ''
				},
				
				/**
				 * True if the element needs to be refocused after blur.
				 */
				_refocus: {
					type: Boolean,
					value: false
				},
				
				/**
				 * Maps the highlightable items to their current indices.
				 */
				_highlighted: {
					type: Object,
					value: function() {
						return {
							/**
							 * Stores the index of the highlighted option inside the selected options list 
							 * ({@link #_selectedOptions}).
							 */
							selectedOptionIdx: -1,
							
							/**
							 * Stores the index of the selected option inside the drop-down options list 
							 * ({@link #_filteredOptions}).
							 */
							filteredOptionIdx: -1,
							
							/**
							 * Stores the currently edited option (inside {@link #_selectedOptions}).
							 */
							editOptionIdx: -1
						}
					}
				},
				
				/**
				 * Stores the status properties of the select element. 
				 * Mainly used for data bindings (element UI) / event handler methods to define the element's behavior.
				 * 
				 * Note: all properties here must be re-initialized on the `create` handler to avoid shared state issues.
				 * They are specified here for documentation purposes!
				 * 
				 * @private
				 */
				_status: {
					type: Object,
					value: function() {
						return {
							/**
							 * The mode gives the overall behavior of the element and reflects the current focused sub-component.
							 * 
							 * Available modes:
							 * - '': the initial state, used when not focused;
							 * - 'view': when a selected option is selected;
							 * - 'query': when the add/query input is focused;
							 * - 'edit': When editing a selected option.
							 * 
							 * @type {String}
							 */
							mode: '',
							
							/**
							 * Whether the element has focus.
							 */
							focused: false,
							
							/**
							 * Whether the dropdown (options) menu is open.
							 */
							open: false,
							
							/**
							 * Will be set true while the options array is loading.
							 */
							optionsLoading: false
						}
					}
				}
				
			},
			
			behaviors: [
				CbnForm.InputElement,
				CbnForm.Validatable,
				CbnForm.DynamicElement,
				CbnDataSource.ConsumerBehavior,
				scope.SelectOptionsBehavior
			],
			
			/**
			 * Element's dynamic attributes.
			 */
			dynamicAttributes: {
				"multiple": { type: 'attribute' },
				"freeText": { type: 'attribute' },
				"allowDuplicates": { type: 'attribute' },
				"options": { type: 'property' },
				"dataSource": { type: 'property' },
				"itemLabelProperty": { type: 'attribute' },
				"itemValueProperty": { type: 'attribute' },
				"filterProperty": { type: 'attribute' },
				"filterMode": { type: 'attribute' },
				"placeholder": { type: 'attribute' },
				"alwaysShowChips": { type: 'attribute' }
			},
			
			hostAttributes: {
				'tab-index': -1
			},
			
			listeners: {
				'mousedown': '_mouseDownHandler'
			},
			
			/**
			 * Whether the options list is empty.
			 */
			get _emptyOptionsList() {
				return !this._status.optionsLoading && !this._filteredOptions.length;
			},
			
			/**
			 * Whether to display/use the selected option chips or just a simple input containing the selected value.
			 */
			get _showChips() {
				return this.multiple || this.alwaysShowChips;
			},
			
			
			// Private methods: 
			
			/**
			 * Used to normalize element's event handler methods.
			 */
			created: function() {
				// bind some internally used event handlers to 'this'
				this._focusHandler = this._focusHandler.bind(this);
				this._blurHandler = this._blurHandler.bind(this);
				this._keyDownHandler = this._keyDownHandler.bind(this);
			},
			
			/**
			 * Callback when an element instance is attached to the DOM. Used to set up event handlers.
			 */
			attached: function() {
				// capture those events for the element itself and all its children
				this.addEventListener('focus', this._focusHandler, true);
				this.addEventListener('blur', this._blurHandler, true);
				this.addEventListener('keydown', this._keyDownHandler, true);
			},
			
			/**
			 * Callback when an element instance is attached to the DOM. Used to clean up event handlers.
			 */
			detached: function() {
				this.removeEventListener('focus', this._focusHandler, true);
				this.removeEventListener('blur', this._blurHandler, true);
				this.removeEventListener('keydown', this._keyDownHandler, true);
			},
			
			// Event handlers: 
			
			/**
			 * Captures the focus event on any of the element's children.
			 */
			_focusHandler: function(event) {
				this._refocus = false;
				if (this._status.focused) 
					return;
				this.set('_status.focused', true);
				
				if (!this._status.mode)
					this._setMode('query');
			},
			
			/**
			 * Captures the blur event on any of the element's children.
			 */
			_blurHandler: function() {
				this.async(function() {
					if (this._refocus || this.contains(document.activeElement)) {
						// a child element was clicked, maintain focus
						this.focus();
					} else {
						if (this._inputValue) {
							this.select(this._inputValue);
							this._clearQueryInput();
						}
						this.set('_status.focused', false);
						this._setMode('');
					}
				});
			},
			
			/**
			 * Receives all mouse down events (for the element and its children).
			 * Used to prevent losing focus when one of the children is clicked.
			 */
			_mouseDownHandler: function() {
				this._refocus = true;
				setTimeout(function() {
					// WARNING: needs to execute after macrotask!
					this._refocus = false;
				}.bind(this), 0);
			},
			
			/**
			 * Captures the keyDown for the select element or any of its children.
			 * @param {Event} event The captured event.
			 */
			_keyDownHandler: function(event) {
				function isPrintable(event) {
					var keycode = event.keyCode;
					return (keycode > 47 && keycode < 58)   || // number keys
						keycode == 32 || keycode == 13   || // spacebar & return key(s) (if you want to allow carriage returns)
						(keycode > 64 && keycode < 91)   || // letter keys
						(keycode > 95 && keycode < 112)  || // numpad keys
						(keycode > 185 && keycode < 193) || // ;=,-./` (in order)
						(keycode > 218 && keycode < 223);   // [\]' (in order)
				}
				
				var proceed, dispatch = this._keyDispatch[this._status.mode][event.keyCode] || this._keyDispatch[event.keyCode];
				var hasModifiers = event['altGraphKey'] || event['metaKey'] || event.altKey || event.shiftKey;
				if (dispatch && !hasModifiers) {
					if (typeof dispatch == 'number' || typeof dispatch == 'string') {
						dispatch = this._keyDispatch[this._status.mode][dispatch];
					}
					if (typeof dispatch == 'function') {
						proceed = dispatch.call(this, event);
					}
					if (!proceed) {
						event.preventDefault();
					}
					
				} else if (isPrintable(event) && this._status.mode == 'view') {
					// focus the input
					this._setMode('query');
					this.$.input.value += String.fromCharCode(1*event.charCode);
				}
			},
			
			/**
			 * A map of keydown event handlers, indexed by element mode and keyCode.
			 */
			_keyDispatch: {
				'': {
				},
				
				view: { // when one of the chosen options is highlighted
					
					/* backspace */  8: function() { /* Deselects the currently highlighted value. */
						this._removeSelectedOption();
					},
					
					/* enter     */ 13: function() {
						if (this._highlighted.selectedOptionIdx < 0 || 
								this._highlighted.selectedOptionIdx >= this._selectedOptions.length) 
							return;
						this._setMode('edit', this._highlighted.selectedOptionIdx);
					},
					
					/* escape    */ 27: function() {
						this._setMode('query');
					},
					
					/* left arr  */ 37: function() { this._highlightSelectedItem(-1, true); },
					/* right arr */ 39: function() {
						if (this._highlighted.selectedOptionIdx >= (this._selectedOptions.length - 1)) {
							this._setMode('query');
						} else {
							this._highlightSelectedItem(1, true);
						}
					},
					/* delete    */ 46: function() { this._removeSelectedOption(); }
				},
				
				query: { // when the main/query input is focused
					
					/* backspace */ 8: function() {
						if (!this._inputValue.length) {
							// another backspace removes the last selected item 
							if (this._selectedOptions.length) {
								this.deselect(this._selectedOptions[this._selectedOptions.length-1].item);
							}
							return false;
						}
						return true;
					},
					
					/* escape    */ 27: function() {
						this._setMode('');
					},
					
					/* enter     */ 13: function() {
						if (this._highlighted.filteredOptionIdx > -1) {
							this.select(this._filteredOptions[this._highlighted.filteredOptionIdx].item);
						} else {
							this.select(this._inputValue);
						}
						this._clearQueryInput();
						if (!this._showChips) {
							this.blur();
						}
					},
					
					/* left arr  */ 37: function() {
						if (this._inputValue.length || !this._selectedOptions.length)
							return true;
						this._setMode('view');
						this._highlightSelectedItem('last');
						return false;
					}
				},
				
				edit: { // when a selected option is currently being edited
					
					/* enter  */ 13: function() { this._saveEditedOption(); },
					
					/* escape */ 27: function() {
						this._setMode('view', this._highlighted.selectedOptionIdx);
					}
				},
				36: function(){ this._setMode('query'); this._highlightDropdownItem('first');  }, // home
				33: function(){ this._setMode('query'); this._highlightDropdownItem(-5, true); }, // page up
				38: function(){ this._setMode('query'); this._highlightDropdownItem(-1, true); }, // up arrow
				34: function(){ this._setMode('query'); this._highlightDropdownItem(5, true);  }, // page down
				40: function(){ this._setMode('query'); this._highlightDropdownItem(1, true);  }, // down arrow
				35: function(){ this._setMode('query'); this._highlightDropdownItem('last');   }, // end
				
				/* escape    */ 27: function() {
					this._clearQueryInput();
					this.blur();
				}
			},
			
			/**
			 * Called when a dropdown option has been clicked / tapped.
			 * 
			 * @param {Object} event The captured event.
			 */
			_dropdownOptionTap: function(event) {
				var item = event.model.item;
				this.select(item.item);
				this._clearQueryInput();
				if (!this.multiple) {
					this._setMode('view');
					this.set('_status.open', false);
				}
			},
			
			/**
			 * Called when a selected option has been clicked / tapped.
			 * 
			 * @param {Object} event The captured event.
			 */
			_selectedOptionTap: function(event) {
				/** @namespace event.model */
				var item = event.model.item;
				if (!item) return;
				if (item.editing) return; // don't interrupt the edit!
				var idx = this._selectedOptions.indexOf(item);
				this._setMode('view', idx);
			},
			
			/**
			 * Called when a selected option has been double clicked.
			 * Enables the edit mode on the clicked item.
			 * 
			 * @param {Object} event The captured event.
			 */
			_selectedOptionDblClick: function(event) {
				if (this._status.mode != 'view' && this._status.mode != 'query') 
					return;
				
				/** @namespace event.model */
				var item = event.model.item;
				var idx = this._selectedOptions.indexOf(item);
				if (!item) return;
				this._highlightSelectedItem(idx);
				this._setMode('edit', this._highlighted.selectedOptionIdx);
				
				// wait for the UI to update
				this.async(function() {
					var optionEditor = event.target.querySelector('.option-editor');
					if (optionEditor) {
						optionEditor.focus();
						optionEditor.setSelectionRange(0, optionEditor.value.length);
					}
				});
			},
			
			/**
			 * Called when the remove selected option button has been clicked.
			 * 
			 * @param {Object} event The captured event.
			 */
			_removeBtnTap: function(event) {
				/** @namespace event.model */
				var item = event.model.item;
				event.stopPropagation();
				if (!item) return;
				this.deselect(item.item);
			},
			
			/**
			 * Called when the dropdown opener button is clicked/tapped.
			 */
			_dropDownButtonTap: function() {
				this._setMode('query');
			},
			
			/**
			 * Called when the query input has been modified.
			 * 
			 * @param {Event} event The input event object.
			 */
			_queryInputHandler: function(event) {
				this._inputValue = event.target.value;
				
				// clear any dropdown option selection
				this._highlightDropdownItem(null);
				
				// query/filter the options on the fly
				this._queryOptions(this._inputValue);
				if (!this.freeText) {
					// highlight the first option found
					this._highlightDropdownItem('first');
				}
			},
			
			/**
			 * Called after the selected value is updated.
			 */
			_valueCommittedCallback: function() {
				// insert metadata defaults
				this._selectedOptions.forEach(function(item, idx) {
					this.set('_selectedOptions.'+idx+'.highlighted', !!item.highlighted);
					this.set('_selectedOptions.'+idx+'.editing', !!item.editing);
				}.bind(this));
				
				if (this.multiple && !this.allowDuplicates) {
					this._filterOptions(/**@type {String}*/this._currentFilterValue);
				}
				this._updateInputValue();
			},
			
			/**
			 * Called when the internal list of options is changed.
			 * Used to store own metadata among the `SelectOptionMeta` objects.
			 */
			_optionsChangedCallback: function() {
				// insert metadata defaults
				this._options.forEach(function(item, idx) {
					this.set('_options.'+idx+'.highlighted', !!item.highlighted);
				}.bind(this));
			},
			
			/**
			 * Called when a new request for options has been sent and it's currently loading.
			 */
			_optionsLoadingCallback: function() {
				// the loading parameter will be set back to false when the `cbn-data-available` event is fired
				this.set('_status.optionsLoading', true);
			},
			
			/**
			 * Called when the options have finished loading (e.g. the dataSource's AJAX request finished).
			 */
			_optionsLoadedCallback: function() {
				this.set('_status.optionsLoading', false);
			},
			
			/**
			 * Called after the options were [re]filtered.
			 */
			_optionsFilteredCallback: function() {
				if (!this._highlighted) {
					// the callback is called while still in the properties configuration phase
					this.async(function() {
						this._optionsFilteredCallback();
					});
					return;
				}
				
				if (this._highlighted.filteredOptionIdx > -1) {
					// un-highlight the currently active element
					if (this._filteredOptions[this._highlighted.filteredOptionIdx]) {
						this.set('_filteredOptions.'+this._highlighted.filteredOptionIdx+'.highlighted', false);
					}
				}
				
				if (this._highlighted.filteredOptionIdx > -1) {
					this._highlightDropdownItem(this._highlighted.filteredOptionIdx);
				}
			},
			
			
			// UI property computation methods
			
			/**
			 * Returns the value of the `_showChips` read-only property. 
			 * Necessary for use as computed data binding.
			 * 
			 * @return {Boolean} Whether to show selected options as chips.
			 */
			_computeShowChips: function() {
				return this._showChips;
			},
			
			/**
			 * Returns the value of the `_emptyOptionsList` read-only property. 
			 * Necessary for use as computed data binding.
			 * @return {Boolean} Whether the options list is empty.
			 */
			_computeEmptyOptionsList: function() {
				return this._emptyOptionsList;
			},
			
			/**
			 * Computes the CSS classes for #container.
			 * 
			 * @param open The observed `_status.open` value.
			 * @return {String} The computed classes (space-separated).
			 */
			_computeContainerClass: function(open) {
				return scope.utils.tokenList({ open: open });
			},
			
			/**
			 * Computes the CSS classes for a selected item.
			 * 
			 * @param highlighted The observed `item.highlighted` value.
			 * @param editing     The observed `item.editing` value.
			 * @return {String} The computed classes (space-separated).
			 */
			_computeSelectedItemClass: function(highlighted, editing) {
				return scope.utils.tokenList({
					'selected-item': true,
					highlighted: highlighted,
					editing: editing
				});
			},
			
			/**
			 * Computes the CSS classes for a dropdown item.
			 * 
			 * @param highlighted The observed `item.highlighted` value.
			 * @return {String} The computed classes (space-separated).
			 */
			_computeDropdownItemClass: function(highlighted) {
				return scope.utils.tokenList({
					item: true,
					highlighted: highlighted
				});
			},
			
			/**
			 * Computes the option edit input's size.
			 * 
			 * @param editQuery The `_editQuery` value.
			 */
			_computeEditInputSize: function(editQuery) {
				return editQuery.length < 5 ? 1 : editQuery.length-1;
			},
			
			
			// Behavioral methods
			
			/**
			 * Changes the element's mode (see {@link #_status}).
			 * 
			 * @param {String} mode The new mode to activate.
			 * @param {*}      [param] Optional mode parameters.
			 * @return {Boolean} True if the mode change succeeded.
			 */
			_setMode: function(mode, param) {
				// first, reset all status variables to their default values
				if (this._highlighted.editOptionIdx > -1) {
					if (this._selectedOptions[this._highlighted.editOptionIdx]) {
						this.set('_selectedOptions.'+this._highlighted.editOptionIdx+'.editing', false);
					}
					this.set('this._highlighted.editOptionIdx', -1);
				}
				
				var oldMode = this._status.mode;
				this.set('_status.mode', mode);
				
				switch (mode) {
					case '':
						this.set('_status.open', false);
						break;
					
					case 'view':
						if (param !== undefined) {
							this._highlightSelectedItem(param);
						}
						// else: keep all highlights intact
						break;
					
					case 'query':
						// show the auto-complete box
						this.set('_status.open', true);
						
						if (oldMode == mode) {
							break;
						}
						
						this._queryOptions(this._showChips ? this._inputValue : '');
						
						// reset all highlights
						this._highlightSelectedItem(null);
						this._highlightDropdownItem(null);
						
						// focus the add/query input
						this.$.input.focus();
						break;
					
					case 'edit':
						// long list of conditions for edit to apply: 
						if (!this.freeText) return false;
						if (param === undefined) return false;
						var item = this._selectedOptions[param];
						if (!item) return false;
						
						this.set('_editQuery', item.label);
						this.set('_highlighted.editOptionIdx', param);
						this.set('_selectedOptions.'+param+'.editing', true);
						
						break;
				}
				
				return true;
			},
			
			/**
			 * Clears the query input text.
			 */
			_clearQueryInput: function() {
				this._inputValue = '';
				this._queryOptions('');
				
				this._updateInputValue();
			},
			
			/**
			 * If {@link #_showChips} is true, updates `_inputValue` to the currently selected value.
			 */
			_updateInputValue: function() {
				if (!this._showChips) {
					// show the final selected value
					this._inputValue = (this._selectedOptions.length ? this._selectedOptions[0].label : '' );
				}
			},
			
			/**
			 * Saves the currently edited option and disabled edit mode.
			 */
			_saveEditedOption: function() {
				if (this._status.mode != 'edit') 
					return false;
				var item = this._selectedOptions[this._highlighted.editOptionIdx];
				if (!item) return false;
				
				if (!this._editQuery) {
					this.deselect(item.item);
					this._setMode('view');
				} else {
					this._transaction = true;
					
					this.deselect(item.item);
					this.select(this._editQuery, this._highlighted.editOptionIdx);
					this._commitValue();
					this._setMode('view', this._highlighted.editOptionIdx);
				}
			},
			
			// Navigation methods
			
			/**
			 * Highlights an option in the dropdown options box.
			 * See {@link #_calcHighlightIndex}.
			 * 
			 * @param {int|String} idx The index of the option to highlight.
			 * @param {Boolean}    [relative] Whether the index is relative to the currently highlighted item.
			 */
			_highlightDropdownItem: function(idx, relative) {
				var curIdx = this._highlighted.filteredOptionIdx;
				idx = this._calcHighlightIndex(idx, relative, this._filteredOptions, curIdx);
				
				if (curIdx > -1 && curIdx < this._filteredOptions.length) {
					this.set('_filteredOptions.'+curIdx+'.highlighted', false);
				}
				if (idx > -1) {
					this.set('_filteredOptions.'+idx+'.highlighted', true);
				}
				this.set('_highlighted.filteredOptionIdx', idx);
			},
			
			/**
			 * Highlights a selected option in the view mode.
			 * See {@link #_calcHighlightIndex}.
			 * 
			 * @param {int|String} idx The index of the option to highlight.
			 * @param {Boolean}    [relative] Whether the index is relative to the currently highlighted item.
			 */
			_highlightSelectedItem: function(idx, relative) {
				var curIdx = this._highlighted.selectedOptionIdx;
				idx = this._calcHighlightIndex(idx, relative, this._selectedOptions, curIdx);
				
				if (curIdx > -1 && curIdx < this._selectedOptions.length) {
					this.set('_selectedOptions.'+curIdx+'.highlighted', false);
				}
				if (idx > -1) {
					this.set('_selectedOptions.'+idx+'.highlighted', true);
				}
				this.set('_highlighted.selectedOptionIdx', idx);
			},
			
			/**
			 * Generic highlight computation routine that returns the absolute index of the item to be highlighted.
			 * 
			 * @param {int|String} idx The index of the option to highlight.
			 * @param {Boolean}    relative Whether the index is relative to the currently highlighted item.
			 * @param {Array}      arr The target options array.
			 * @param {int}        curIdx The index of the currently highlighted item.
			 * @return {int} The absolute index of the item to highlight.
			 */
			_calcHighlightIndex: function(idx, relative, arr, curIdx) {
				var absIdx = idx;
				
				if (!arr.length) // nothing to select
					return -1;
				if (idx === null) // de-highlight
					return -1;
				
				if (curIdx == -1 && relative) {
					if (idx > 0) idx = 'first';
					if (idx < 0) idx = 'last';
				}
				if (idx == 'first') {
					absIdx = 0;
				} else if (idx == 'last') {
					absIdx = arr.length-1;
				} else if (relative) {
					absIdx = curIdx + idx;
				}
				if (absIdx < 0) absIdx = 0;
				if (absIdx >= arr.length) absIdx = arr.length-1;
				
				return absIdx;
			},
			
			/**
			 * Removes the current highlighted option from the selected options list.
			 */
			_removeSelectedOption: function() {
				if (this._highlighted.selectedOptionIdx < 0) 
					return;
				if (this._highlighted.selectedOptionIdx >= this._selectedOptions.length) 
					return;
				this.deselect(this._selectedOptions[this._highlighted.selectedOptionIdx].item);
				
				// try to highlight the next item
				// (if not possible, the last item will be chosen)
				this._highlightSelectedItem(this._highlighted.selectedOptionIdx);
			}
			
		};
		
		Polymer(scope.CbnSelectPrototype);
		
		CbnForm.registerElement('cbn-select', {
			types: [ 'select' ],
			priority: 1
		});
		
	})(window.CbnForm.CbnSelect);
	
</script>
